
## 1. 쓰레드와 프로세스

### 1. 프로세스
* 실행중인 프로그램이다.
* 프로그램을 실행하면 OS로부터 필요한 자원을 할당받아 프로세스가 된다 -> 프로세스에 종속적
* 프로세스는 데이터 + 메모리 + 쓰레드로 구성
* 둘 이상의 쓰레드를 가진 프로세를 멀티쓰레드라고 부름

### 2. 쓰레드
* 프로세스라는 작업공간에서 작업을 처리하는 일꾼
* 프로세스의 성능이 단순히 쓰레드의 개수에 비례하는 것은 아님

## 2. 멀티쓰레딩
### 1. 멀티쓰레딩의 장점
* CPU 사용률 향상
* 자원의 효율적 사용
* 사용자 응답성 향상
* 작업이 분리되어 코드가 간결해짐

### 2. 멀티쓰레딩의 단점
* 여러 쓰레드가 동일 프로세스에서 작업하기 때문에 동기화 문제 
* 교착상태 문제
* 컨텍스트 스위칭으로 인한 효율 저하

## 3. 간단한 쓰레드 사용 방법
### 1. 쓰레드의 구현과 실행
* Runnable 인터페이스 구현
```
/* 선언방법 */

Class MyThread implements Runnable {
	public void run() {
		/* 작업내용
		 * runnable 인터페이스에 추상메서드 run()을 구현
		 */
	}
}


/* 생성 방법 */

Runnable r = new MyThread();
Thread t2 = new Thread(r);


/* 사용 방법 */
t2.start();
```

* Thread 클래스 상속
```
/* 선언 방법 */
class MyThread extends Thread {
	public void run() {
		/* 작업내용
		 * Thread 클래스의 run() 오버라이딩 
		 */
	}
}

/* 생성 방법 */

Thread t1 = new MyThread();


/* 사용 방법 */
t1.start();
```

### 2. 차이점
* Thread는 상속을 받으며 Runnable은 인터페이스로서 구현한다
* Thread는 재사용이 불가능하며 Runnable은 가능하다
* Thread 사용시 다른 클래스를 상속받을 수 없다 

### 3.  start() 와 run()
* run() 메소드를 호출한다면 클래스에 선언된 메소드만 호출하는 것
* start()는 새로운 쓰레드가 작업하는데 필요한 호출 스택을 생성
* 호출 스택을 생성한 다음 가장 먼저 run() 메서드를 호출스택에 올림
* main 메서드의 모든 작업도 main 쓰레드에서 동작
* 실행중인 ‘사용자 쓰레드’가 하나도 없을 때  프로그램은 종료 된다.

## 4. 쓰레드 동기화
* 멀티쓰레드 작업일 경우 여러 쓰레드가 프로세스 내의 자원을 공유
* 공유자원 상태에 영향을 끼칠 수 있음
* 특정 작업을 끝마치기 전까지 다른 쓰레드로 부터 방해받지 않는 방법이 필요
* 임계영역 (critical section)
* 락 (lock)
 
### 1. synchronized
* 임계영역을 지정하는데 사용
```
/* 1. 메소드 전체를 임계영역으로 설정 */ 
public synchronized void calcSum() {
	/* 임계 영역 */
}


/* 2. 특정한 영역을 임계 영역으로 지정
synchronized (객체의 참조변수) {
	/* 임계 영역 */
}

// 객체의 참조변수란 락을 걸고자 하는 객체를 참조하는 것
// 보통 해당 임계영역을 호출한 객체를 표현 -> 주로 this
// 동기화 블럭안에 전달된 객체를 모니터 객체라고 부름
```

### 2. wait() , notify()
* synchronized로 동기화된 임계영역을 상주하는 쓰레드 문제 
* 락을 가진 상태로 오랜 시간을 보내는것은 자원 낭비
* 동기화된 임계영역에서 코드 수행이 어려울 경우 wait() 호출을 통해 대기상태로 진입
* 작업을 진행 할 수 있는 상황이 되면 notify() 를 호출하여 작업을 중단했던 스레드가 다시 락을 얻어 작업을 진행할 수 있게 함
* notify() 같은 경우 원하는 쓰레드에 전달이 안될 수도 있기 때문에 notifyAll()을 호출함
* 기아현상 발생 가능
	* 대기상태로 들어간 쓰레드가 notify() 통지를 받지 못하고 계속해서 기다리는 현상
	* notifyAll()을 사용해 모든 쓰레드에게 통지하여 기아 상태를 해결
	* 모든 쓰레드가 notify() 받기 때문에 필요없는 쓰레드들이 lock을 얻기위해 경쟁함
	* 이를 경쟁상태라 부름

### 3. volatile
* 코어 <-> cache <-> memory 사이에서 일어나는 문제에서 사용
* 메모리에 저장된 변수값과 캐시에 저장된 변수 값이 달라 문제 발생
```
boolean suspended = false;
->
volatile boolean suspended = false;
```

* synchronized 블럭도 캐시와 메모리 사이 동기화가 이루어짐
* volatile 를 활용하여 명령을 원자화 시킴
* 명령을 원자화 하는것과 동기화를 하는것은 아님

### 4. For & join 프레임워크

## 5. Spring의 쓰레드
### 1.ThreadPoolTaskExecutor
### 2.@Async

## 6. Java 8의 쓰레드